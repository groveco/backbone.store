<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: internal-model.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: internal-model.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import _ from 'underscore'
import { Model } from 'backbone'

function attributesWithDefaults (attributes, defaults) {
  return _.defaults(_.extend({}, defaults, attributes), defaults)
}

/**
 * Check if an object is a valid resource identifier
 * @see https://jsonapi.org/format/#document-resource-identifier-objects
 *
 * @param {object} relationship Resource Identifier
 * @returns {boolean} Returns true if valid
 */
function isValidResourceIdentifier (relationship) {
  return Boolean(_.result(relationship, 'id') &amp;&amp; _.result(relationship, 'type'))
}

/**
 * Exports a Backbone model extended with utility methods that enables the
 * retrieval of data based on {@link https://jsonapi.org/ JSON:API} formatted responses
 * @module internal-model
 */
export default Model.extend({
  /**
   * Constructs a Backbone Model with the given attributes passed to it
   * @param {Object} attributes - Object with attributes
   */
  constructor: function (attributes) {
    _.defaults(this, {
      defaults: { },
      attributes: { },
      computed: { },
      changed: { }
    })

    _.extend(this, {
      cid: _.uniqueId(this.cidPrefix)
    })

    const defaults = _.result(this, 'defaults')

    this.set(attributesWithDefaults(attributes, defaults))

    this.initialize.apply(this, arguments)
  },

  toJSON () {
    const attributes = _.clone(this.attributes)
    const computed = _.mapObject(this.computed, (cp) => cp.call(this))
    return _.extend(attributes, computed)
  },

  /**
   * {Backbone.Model} does not provide "computed" properties.
   *
   * @param {string} attr name
   * @return {mixed|undefined} via {attributes[attr]} or {computed[attr]}
   */
  get (attr) {
    if (this.attributes.hasOwnProperty(attr)) return this.attributes[attr]

    if (this.computed.hasOwnProperty(attr)) return this.computed[attr].call(this)

    return undefined
  },

  getRelationshipLink (relationName) {
    const link = _.result(this.getRelationship(relationName), ['links', 'related'])

    if (link == null) {
      throw new Error(`link for, "${relationName}", is undefined for ${this.get('_type')}-${this.id}`)
    }

    return link
  },

  _getRelationForName (relationName) {
    return this.relationships &amp;&amp; this.relationships[relationName]
  },

  /**
   * Get the relationship's {@link https://jsonapi.org/format/#document-resource-object-relationships resource object}
   * from the {@link https://jsonapi.org/ JSON:API} response. If the given `relationName` does not
   * exist or the relationship object returned is null, then an
   * exception is thrown. Otherwise, the relationship object for the
   * given `relationName` is returned
   * @param {String} relationName - The name of a given resource found within the response's relationship's object
   * @param {Boolean} strict - A boolean indicating whether method is ran in strict mode.
   * @returns {Object} - The relationships object from the {@link https://jsonapi.org/ JSON:API}
   */
  getRelationship (relationName, strict = true) {
    const modelName = this._getRelationForName(relationName)

    if (modelName == null &amp;&amp; strict) {
      if (strict) throw new Error('Relation for "' + relationName + '" is not defined on the model.')

      return null
    }

    const relationship = _.result(this.get('relationships'), relationName)

    if (relationship == null) {
      if (strict) throw new Error('There is no relationship "' + relationName + '" in the resource.')

      return null
    }

    return relationship
  },

  getRelationshipData (relationName, strict = true) {
    return _.result(this.getRelationship(relationName, strict), 'data')
  },

  getRelationshipType (relationName) {
    const relationship = this.getRelationshipData(relationName)

    if (_.isArray(relationship)) return 'has-many'

    if (relationship) return 'belongs-to'

    return null
  },

  /**
   * Check if the given relation exists
   * @param {string} relationName - The name of a registered Model in a responses relationship
   * @returns {Boolean} true if relationship exists
   */
  hasRelated (relationName) {
    const relatedData = this.getRelationshipData(relationName, false)

    if (_.isEmpty(relatedData)) return false

    if (_.isArray(relatedData)) return _.reduce(relatedData, (acc, data) => acc &amp;&amp; isValidResourceIdentifier(data), true)

    return isValidResourceIdentifier(relatedData)
  },

  /**
   * Get a stores related model. Will return the model in the cache
   * if it has already been fetched. If not, then we fetch the response
   * from the server
   * @param {string} relationName - The name of a registered Model in a responses relationship
   * @param {Object} queryObj - An object that will have it's key:value pairs converted to a
   * query string.
   * @returns { CollectionProxy | ModelProxy }
   */
  getRelated (relationName, queryObj) {
    const link = this.getRelationshipLink(relationName)

    const related = this.getRelationshipData(relationName)

    if (!related) return this.fetchRelated(relationName, queryObj)

    return _.isArray(related)
    ? this.store.getHasMany(this, link, related, queryObj)
    : this.store.getBelongsTo(this, link, related.type, related.id, queryObj)
  },

  /**
   * Fetch a stores related model from the server.
   * @param {string} relationName - The name of a registered Model in a responses relationship
   * @param {Object} queryObj - An object that will have it's key:value pairs converted to a
   * query string.
   * @returns { CollectionProxy | ModelProxy }
   */
  fetchRelated (relationName, queryObj) {
    const link = this.getRelationshipLink(relationName)

    const related = this.getRelationshipData(relationName)

    if (!related) return this.store.fetchUnknown(link, queryObj)

    return (_.isArray(related))
    ? this.store.fetchHasMany(this, null, link, queryObj)
    : this.store.fetchBelongsTo(this, link, related.type, related.id, queryObj)
  }
})
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-internal-model.html">internal-model</a></li></ul><h3>Classes</h3><ul><li><a href="CollectionProxy.html">CollectionProxy</a></li><li><a href="ModelProxy.html">ModelProxy</a></li><li><a href="module.exports.html">exports</a></li><li><a href="Store.html">Store</a></li></ul><h3>Global</h3><ul><li><a href="global.html#_checkSerializeRequests">_checkSerializeRequests</a></li><li><a href="global.html#_http">_http</a></li><li><a href="global.html#_makeRequest">_makeRequest</a></li><li><a href="global.html#buildUrl">buildUrl</a></li><li><a href="global.html#isValidResourceIdentifier">isValidResourceIdentifier</a></li><li><a href="global.html#request">request</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Fri Jan 15 2021 18:05:58 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
